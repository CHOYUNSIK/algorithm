package fortytwodot;

import java.util.*;

/*

### 문제 설명

N × N 크기의 게임 보드 위에 폭탄과 장애물이 설치되어 있습니다.
게임 보드 위의 폭탄은 터질 때 **상, 하, 좌, 우 4개 방향**으로 각각 k칸 거리만큼 불기둥을 뿜습니다.
이때, **폭탄의 영향 범위에 캐릭터가 있으면 게임은 끝**납니다.
단, **불기둥은 장애물을 통과하지 못합니다.**
따라서 불기둥이 지나가는 자리에 장애물이 있다면, 장애물 뒤에 숨어서 불기둥을 피할 수도 있습니다.

다음은 N = 6, k = 2인 경우, 6 x 6 크기의 게임 보드 위에 장애물과 폭탄이 설치된 상태를 나타낸 그림입니다.

![[Pasted image 20250628214229.png]]

위 그림에서 **4번 폭탄이 터진다면**
상, 하, 좌, 우 4개 방향으로 각각 2칸씩 불기둥이 뿜어져 나옵니다
(게임 보드를 벗어나는 불기둥은 무시).
만약 3번 폭탄이 터진다면 불기둥은 **장애물을 넘을 수 없기 때문에**
아래와 같이 불기둥이 생기게 됩니다.
![[Pasted image 20250628214255.png]]


위 예시에서 **모든 폭탄이 동시에 터진다면**
아래 그림과 같이 빨간 영역이 폭발 범위가 됩니다.

![[Pasted image 20250628214336.png]]


A, B에 위치한 캐릭터를 **폭발의 영향이 미치지 않는 안전한 칸으로 이동시키려고** 합니다.
각 캐릭터는 **상, 하, 좌, 우 방향으로 한 칸씩 이동**하거나
가만히 있을 수 있으며, **각각의 행동에는 1초씩 소요**됩니다.
또, 캐릭터는 **장애물과 폭탄을 통과할 수 없으며**,
두 캐릭터가 **동시에 이동할 때는 이동한 결과가 겹치지 않도록 이동**해야 합니다.
예를 들어 다음과 같은 이동은 가능합니다.

![[Pasted image 20250628214358.png]]

그러나 다음과 같이 이동 후에 두 캐릭터가 **같은 칸에 위치해서는 안 됩니다.**

![[Pasted image 20250628214451.png]]



폭탄과 장애물이 놓여있는 게임 보드의 상태 `board`와
폭탄의 폭발 범위 `k`,
A 캐릭터의 좌표 `(ax, ay)`,
B 캐릭터의 좌표 `(bx, by)`가 매개변수로 주어질 때,

게임 보드 위에 놓여있는 **모든 폭탄이 동시에 터지기 전까지**
두 캐릭터 모두 폭탄의 영향이 미치지 않는 **안전한 장소로 동시에 이동**시키는 데
**필요한 최소 시간**을 `return` 하도록 `solution` 함수를 완성하세요.

---

### 제한사항

- `board`는 게임 보드의 상태를 나타내는 N x N 크기의 2차원 배열로, N은 2 이상 15 이하의 자연수입니다.

- `board`의 각 원소는 게임 보드의 각 칸의 상태를 나타내며, **빈칸은 0, 폭탄은 1, 장애물은 2**로 나타냅니다.

- 게임 보드 위엔 **빈칸은 반드시 2개 이상** 존재합니다.

- 폭탄의 폭발 범위 `k`는 1 이상 15 이하의 자연수입니다.

- `ax`, `ay`, `bx`, `by`는 캐릭터 A, B가 현재 위치한 칸을 나타내며, x가 세로방향, y가 가로방향을 나타냅니다.

- 각 캐릭터의 위치는 항상 보드 위로 주어지며, 항상 **빈칸에만 주어지고 A와 B가 겹치지 않게** 주어지지 않습니다.

- 좌표는 좌측 위가 (0,0), 우측 아래가 (N-1,N-1)입니다.

- **두 캐릭터를 모두 안전한 장소로 옮길 수 있는 방법이 없다면 -1을 return 하세요.**

---



### 입출력 예
| board                                                                                   | k   | ax  | ay  | bx  | by  | result |
| --------------------------------------------------------------------------------------- | --- | --- | --- | --- | --- | ------ |
| `[[1,2,0,0],[1,0,2,0],[1,0,0,0],[1,0,0,1]]`                                             | 2   | 1   | 1   | 2   | 2   | 5      |
| `[[0,0,1,0,0,0],[0,2,0,0,0,1],[0,0,2,1,0,0],[0,0,0,0,0,0],[0,0,0,0,1,0],[0,1,0,0,0,0]]` | 2   | 1   | 2   | 0   | 5   | 7      |
### 입출력 예 설명

입출력 예 #1
🅐, 🅑 두 위치의 캐릭터를 모두 안전한 장소로 동시에 이동시키기 위해서는 아래와 같이 적어도 5초의 시간이 필요합니다.
![[Pasted image 20250628215237.png]]
좌측은 초기 보드의 상태이며 우측은 🅐, 🅑가 각각 이동한 결과입니다.
![[Pasted image 20250628215243.png]]
🅐, 🅑가 각각 이동합니다.
🅑는 3초쯤에 안전한 위치로 이동하였습니다.
![[Pasted image 20250628215254.png]]

🅐, 🅑가 겹치도록 이동하는 것은 불가능 하므로 🅑를 이동시키지 않고 🅐가 안전한 곳으로 이동할 수 없습니다.
따라서 🅑를 오른쪽으로 이동시킵니다.

두 캐릭터를 모두 안전한 장소로 이동시키기 위해서는 적어도 5초의 시간이 필요하므로 5를 return 합니다.


입출력 예 #2
문제의 예시와 같습니다.
🅐, 🅑 두 위치의 캐릭터를 모두 안전한 장소로 동시에 이동시키기 위해서는 아래와 같이 적어도 7초의 시간이 필요합니다.

![[Pasted image 20250628215319.png]]
2초째의 두 캐릭터의 움직임에서 🅐, 🅑가 겹치도록 이동할 수 없으므로 🅐가 이동할 동안 🅑는 가만히 있습니다.
두 캐릭터 모두 안전한 장소로 이동시키기 위해서는 적어도 7초의 시간이 필요하므로 7을 return 합니다.
* */
public class Step2 {
    static int[] dx = {0,1,0,-1,0};
    static int[] dy = {1,0,-1,0,0};

    int solution(int[][] board, int k, int ax, int ay, int bx, int by) {
        int n = board.length;
        boolean[][] danger = computeDanger(board, k);

        boolean[][][][] visited = new boolean[n][n][n][n];
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{ax, ay, bx, by, 0});
        visited[ax][ay][bx][by] = true;

        while (!q.isEmpty()) {
            int[] s = q.poll();
            int x1 = s[0], y1 = s[1], x2 = s[2], y2 = s[3], t = s[4];

            if (!danger[x1][y1] && !danger[x2][y2]) {
                return t;
            }

            for (int d1 = 0; d1 < 5; d1++) {
                int nx1 = x1 + dx[d1], ny1 = y1 + dy[d1];
                if (nx1 < 0 || nx1 >= n || ny1 < 0 || ny1 >= n || board[nx1][ny1] != 0) {
                    nx1 = x1; ny1 = y1;
                }

                for (int d2 = 0; d2 < 5; d2++) {
                    int nx2 = x2 + dx[d2], ny2 = y2 + dy[d2];
                    if (nx2 < 0 || nx2 >= n || ny2 < 0 || ny2 >= n || board[nx2][ny2] != 0) {
                        nx2 = x2; ny2 = y2;
                    }

                    if (nx1 == nx2 && ny1 == ny2) continue;

                    if (!visited[nx1][ny1][nx2][ny2]) {
                        visited[nx1][ny1][nx2][ny2] = true;
                        q.offer(new int[]{nx1, ny1, nx2, ny2, t + 1});
                    }
                }
            }
        }

        return -1;
    }

    private boolean[][] computeDanger(int[][] board, int k) {
        int n = board.length;
        boolean[][] danger = new boolean[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 1) {
                    danger[i][j] = true;
                    for (int d = 0; d < 4; d++) {
                        for (int step = 1; step <= k; step++) {
                            int ni = i + dx[d] * step, nj = j + dy[d] * step;
                            if (ni < 0 || ni >= n || nj < 0 || nj >= n) break;
                            if (board[ni][nj] == 2) break;
                            danger[ni][nj] = true;
                        }
                    }
                }
            }
        }
        return danger;
    }




    public static void main(String[] args) {
        Step2 sol = new Step2();
        int[][] board1 = {
                {1,2,0,0},
                {1,0,2,0},
                {1,0,0,0},
                {1,0,0,1}
        };
        System.out.println(sol.solution(board1, 2, 1,1,2,2)); // 예상 5

        int[][] board2 = {
                {0,0,1,0,0,0},
                {0,2,0,0,0,1},
                {0,0,2,1,0,0},
                {0,0,0,0,0,0},
                {0,0,0,0,1,0},
                {0,1,0,0,0,0}
        };
        System.out.println(sol.solution(board2, 2, 1,2,0,5)); // 예상 7
    }
}
