
# 1

>아래 질문을 개발자의 관점으로 최대한 상세히 서술해줘
>운영 중인 쇼핑몰에서는 상품 상세 페이지를 빠르게 제공하기 위해 상품 정보를 레디스에 캐시해서 사용하고 있습니다.
>하지만 사용자가 증가하고 쇼핑몰에서 판매하는 제품이 많아지면서 레디스 서버의 부하가 심각해지고 있으며, 간혹 레디스 서버가 중단되는 현상이 발생하고 있습니다.
>이러한 상황에서 어떤 조치를 취할 수 있을까요?

~~~

먼저, 서버 성능을 높이는 방법인 스케일 업을 생각해볼 수 있습니다. 레디스 서버의 CPU나 메모리를 증설하는 것이죠. 하지만 이 방법은 비용이 많이 들고, 한계에 도달하면 더 이상의 성능 향상이 어려울 수 있습니다. 그래서 또 다른 방법인 스케일 아웃을 고려해볼 수 있습니다. 이는 여러 레디스 인스턴스에 데이터를 분산시켜 처리 능력을 향상시키는 방법으로, 시스템의 복잡성은 증가하지만, 훨씬 더 많은 데이터와 트래픽을 처리할 수 있게 됩니다.

캐시 무효화 전략을 재검토하는 것도 중요합니다. 불필요하게 자주 캐시가 갱신되거나 삭제되지 않도록, 캐시의 유효 시간(TTL)을 적절히 설정하고, LRU(Least Recently Used)와 같은 캐시 교체 알고리즘을 적용해보는 것이 좋습니다.

로드 밸런싱을 통해 레디스 서버로 들어오는 요청을 균등하게 분산시키는 것도 하나의 해결책이 될 수 있습니다. 이 방법은 단일 서버에 집중되는 부하를 줄여줄 뿐만 아니라, 서버 중 하나가 실패했을 때 서비스의 가용성을 유지하는 데에도 도움이 됩니다.

마지막으로, 모니터링과 알림 시스템을 갖추는 것은 무척 중요합니다. 이를 통해 부하가 증가하거나 장애가 발생할 조짐을 미리 파악하고, 적절한 조치를 취할 수 있습니다. CPU 사용률, 메모리 사용량, 응답 시간 등을 지속적으로 모니터링하고, 문제가 발생했을 때 빠르게 알림을 받을 수 있는 시스템을 구축하는 것이 중요합니다.

~~~

# 2

>   아래 질문을 개발자의 관점으로 최대한 상세히 서술해줘
>   운영 중인 쇼핑몰이 최근 할인 행사로 상품 주문이 증가하고 있습니다.
>   이에 따라 백엔드 시스템에서 주문 처리 속도가 저하되고, 심지어는 주문 처리에 실패하기도 합니다.
>   다음에 예정된 행사에는 할인율이 높아 더 많은 주문이 몰릴 것으로 예상됩니다.
>   주문 처리 과정은 다음처럼 순차적으로 작업이 이뤄집니다.
> 1. 고객이 주문을 요청합니다.
> 2. 요청된 주문 정보를 데이터베이스에 저장합니다.
> 3. 주문 정보를 기반으로 발주서를 작성하고 사내 타 서비스에 발송합니다.
> 4. 고객에게 주문 처리 완료 메일을 전송합니다.
>    주문 처리 속도와 주문 처리 실패에 대한 다양한 방법을 고민하던 중, 메시지 큐를 도입해 볼 수 있겠다는 생각이 들었습니다.
>    메시지 큐를 이용하면 주문 처리 과정의 일부를 비동기적으로 처리할 수 있으며, 이를 통해 응답 속도도 개선할 수 있고 실패하는 주문도 줄일 수 있겠다는 생각이 들었습니다.
>    다만 신선식품의 경우 배송 마감 시간이 있어 다른 주문보다 빠르게 발주서를 작성하고 발송해야 하는데 메시지 큐를 사용할 때 이 부분이 마음에 걸립니다.
>    아직 신선식품의 주문량은 전체 주문 건수에 비교하면 소규모로 트래픽에 영향을 주는 정도는 미미합니다. 하지만 회사에서는 중요하게 보고 있는 아이템입니다.
> 1. 이런 상황일 때 메시지 큐는 어디서, 어떤 방식으로 사용할 수 있을까요?
> 2. 메시지 큐를 사용할 때 고려해야 할 다른 점이 또 있을까요?
> 3. 그 외 메시지 큐가 아닌 해결 가능한 다른 방법이 있을까요?

~~~
1. 메시지 큐의 활용 방안
주문 정보 저장 후 메시지 큐에 작업 추가: 고객이 주문을 요청하면, 해당 주문 정보를 데이터베이스에 저장하고, 메시지 큐에 주문 처리 작업을 추가합니다. 이렇게 하면 주문 정보 저장과 실제 주문 처리 로직을 비동기적으로 분리할 수 있어, 시스템의 응답 속도를 개선할 수 있습니다.
우선 순위 큐 사용: 신선식품과 같이 시간에 민감한 주문의 경우, 우선 순위를 높게 설정하여 메시지 큐에서 먼저 처리되도록 할 수 있습니다. 이를 통해 배송 마감 시간을 지키면서도, 다른 주문 처리에 영향을 최소화할 수 있습니다.

2. 메시지 큐 사용 시 고려사항
메시지 처리 순서 보장: 특히 주문과 같이 순서가 중요한 작업을 처리할 때는, 메시지가 순서대로 처리되도록 큐 시스템을 올바르게 구성해야 합니다.
모니터링과 로깅: 메시지 큐를 통해 처리되는 작업의 상태를 모니터링하고, 문제 발생 시 신속하게 대응할 수 있도록 로깅 시스템을 갖추어야 합니다.
장애 대비: 메시지 큐 자체의 장애로 인해 시스템 전체에 영향을 미칠 수 있으므로, 메시지 큐의 고가용성(High Availability) 구성을 고려해야 합니다.

3. 메시지 큐 외의 대안 방법
데이터베이스 최적화: 데이터베이스 쿼리 최적화, 인덱싱, 적절한 샤딩 전략 등을 통해 주문 정보 처리 속도를 향상시킬 수 있습니다.
마이크로서비스 아키텍처: 주문 처리 시스템을 별도의 마이크로서비스로 분리하여, 각 서비스가 독립적으로 확장 및 관리될 수 있도록 하는 것입니다. 이를 통해 시스템 전체의 유연성과 확장성을 향상시킬 수 있습니다.
자동 확장 기능: 자동 확장 기능을 활용하여, 트래픽이 증가할 때 자동으로 리소스를 확장하고, 트래픽이 감소하면 축소하여 비용 효율성을 높일 수 있습니다.
캐싱: 자주 접근하는 데이터나 결과를 캐시에 저장하여, 데이터베이스 접근을 최소화하고 응답 속도를 개선할 수 있습니다.
로드 밸런서 사용: 백엔드 서버 앞에 로드 밸런서를 배치하여, 들어오는 요청을 여러 서버에 분산시키는 방법입니다. 이는 시스템의 부하를 줄이고 처리 속도를 향상시킬 수 있습니다.

~~~

# 3

> + 아래 질문을 개발자의 관점으로 최대한 상세히 서술해줘
> 다수의 여행사들에게서 호텔을 API로 제공받아 모아서 판매하는 기능을 개발하려 합니다.
> 사용자가 체크인 날짜, 체크아웃 날짜, 인원 수, 여행지 를 입력하면 이를 기반으로 각 여행사들의 판매 가능한 호텔리스트를 모아서 호텔의 이름과 가격을 화면에 보여주고, 호텔을 선택하면 해당 호텔의 재고와 가격 변동을 확인한 뒤 예약을 하면 예약확정이 된 뒤 사용자에게 예약이 되었다는 알림을 줍니다.
> 기능을 개발 중 아래와 같은 부분들이 발견되었습니다.
> - 여행사들의 호텔리스트를 조회하는 API 호출시 1~5분 정도 소요됩니다.
> - 호텔리스트 조회 API는 각 여행사에서 호출 횟수를 제한하고 있어 호출이 최소화 되어야합니다.
> - 호텔리스트를 조회하면 각 호텔의 가격도 함께 응답에 들어가있습니다.
> - 여행사들의 단일 호텔의 가격/재고를 조회하는 API는 1~2초 정도 소요됩니다.
> - 호텔의 가격과 재고는 여행사의 상황에 따라 비정기적으로 변경됩니다.
> - 여행사의 예약 API 호출시 예약이 확정되기까지 1~5분 정도 소요됩니다.
> - 내 예약페이지 에서 호출하는 여행사의 예약조회 API는 1~2초 정도 소요됩니다.
> - 예약을 조회하면 예약한 호텔/가격 정보와 예약상태를 응답으로 받을 수 있습니다.
>   위의 사항들을 참고하여 구현시 고려해야 할 부분과 어떤 전략으로 구현할지 설명해 주세요.

~~~

구현시 고려해야 할 주요 부분
호텔 리스트 조회 시간의 최적화: 여러 여행사의 API를 호출하는 데 긴 시간이 소요되므로, 사용자 대기 시간을 최소화하는 방법을 모색해야 합니다.
API 호출 횟수의 효율적 관리: API 호출 횟수 제한에 부딪히지 않도록, 호출을 최소화하면서 필요한 정보를 획득하는 전략이 필요합니다.
가격과 재고 정보의 실시간 반영: 호텔의 가격과 재고 정보가 변동적이므로, 사용자에게 최신 정보를 제공할 수 있는 시스템을 구축해야 합니다.
예약 확정까지의 시간 관리: 예약 확정까지 소요되는 시간을 사용자가 인지할 수 있도록 하며, 대기 시간을 줄이는 방법을 고안해야 합니다.
구현 전략
비동기 처리 및 캐싱 기법 도입

사용자가 조회 요청을 하면, 미리 캐싱된 호텔 리스트와 가격 정보를 바탕으로 즉시 응답을 제공합니다. 이 정보는 배경 작업으로 정기적으로 갱신되어야 합니다.
최신 가격 및 재고 정보 확인이 필요한 경우에만 실시간 API 호출을 수행합니다.
호텔 정보의 배치 처리

사용자 요청이 많은 시간대에는 API 호출을 배치 처리하여, 여러 요청을 하나로 묶어 동시에 처리함으로써 API 호출 횟수를 절감할 수 있습니다.
우선 순위 큐와 스마트 캐싱 전략

사용자의 검색 패턴, 인기 있는 여행지, 특정 시즌 등을 분석하여, 더 자주 조회되는 호텔 정보를 우선적으로 캐싱하고 자주 갱신합니다.
이러한 스마트 캐싱은 시스템의 효율성을 높이고, 사용자에게 더욱 신속하고 정확한 정보를 제공할 수 있게 합니다.
사용자 경험 개선

예약 과정에서 발생할 수 있는 긴 대기 시간을 사용자에게 명확히 안내하고, 대기 시간 동안 다른 유용한 정보나 서비스를 제공함으로써 사용자의 인내심을 유지하도록 합니다.
예약 진행 상태를 실시간으로 사용자에게 피드백하여, 사용자가 자신의 예약 상태를 명확히 알 수 있도록 합니다.
실패 대비 전략

API 호출 실패 또는 예약 실패 시, 자동으로 재시도하거나 대체 방법을 모색하는 로직을 구현합니다. 사용자에게는 실패 사유와 재시도 여부를 명확히 안내합니다.

~~~

# 4

> 아래 질문을 개발자의 관점으로 최대한 상세히 서술해줘
> 트위터(혹은 인스타그램, 포털뉴스 서비스 중 택일) 와 같은 규모의 클론 서비스를 구현해야 합니다.
> 지원자는 이제 서비스를 위해 사용할 저장소를 선택해야 합니다.
> 저장해야 할 리소스는 각 서비스의 핵심 컨텐츠입니다.
> 트위터의 경우 짧은 텍스트들, 인스타의 경우 이미지들과 짧은 텍스트 등입니다.
> 저장소는 관계형 데이터베이스, NoSQL, 파일 시스템 등 선택에 제한은 없습니다.
> 1. 구현할 서비스의 저장소 사용 시나리오를 예측해 주세요. 시나리오는 직접 제한을 두시면 됩니다.
>    간단한 예) 트위터 서비스는 읽기가 많고, 쓰기는 적다. 저장할 데이터의 스키마가 단순하다. 등
> 2. 위 시나리오에 맞는 저장소들을 선택하시고, 그 이유를 서술해주세요.

~~~

트위터는 주로 짧은 텍스트 기반의 메시지(트윗)를 사용자들이 게시하는 소셜 미디어 플랫폼입니다. 이러한 특성을 바탕으로 시나리오를 설정해 보겠습니다.

시나리오 예측
읽기 중심의 작업: 트위터와 같은 서비스는 사용자들이 다른 사람의 트윗을 읽는 경우가 많으며, 이는 읽기 작업이 쓰기 작업보다 훨씬 빈번하다는 것을 의미합니다.
단순한 스키마 구조: 트윗은 상대적으로 스키마가 단순한 편이며, 주로 텍스트 내용, 작성자, 작성 시간, 좋아요 수 등으로 구성됩니다.
빠른 데이터 접근: 실시간으로 트윗을 업데이트하고 사용자의 피드에 노출시켜야 하기 때문에, 데이터에 빠르게 접근할 수 있는 저장소가 필요합니다.
확장성: 수백만에서 수억 명의 사용자를 수용할 수 있도록 시스템이 수평적으로 확장 가능해야 합니다.
저장소 선택과 이유
NoSQL 데이터베이스 (예: Cassandra, MongoDB)

이유: NoSQL 데이터베이스는 확장성이 뛰어나고, 대량의 데이터를 효율적으로 처리할 수 있습니다. 읽기 작업이 많은 시나리오에 잘 맞으며, 스키마가 유연하기 때문에 트윗과 같은 단순한 구조의 데이터를 쉽게 저장하고 관리할 수 있습니다. Cassandra는 분산 환경에서 높은 가용성을 제공하며, MongoDB는 문서 지향적 특성으로 개발의 용이성을 제공합니다.
캐싱 시스템 (예: Redis, Memcached)

이유: 빈번한 읽기 작업과 실시간 데이터 업데이트를 지원하기 위해, 자주 접근하는 데이터를 메모리에 캐싱합니다. 이는 데이터 접근 시간을 대폭 줄여주어 사용자에게 빠른 응답 속도를 제공합니다. Redis 같은 캐싱 시스템은 데이터의 빠른 읽기와 쓰기를 지원하며, 데이터 구조를 효율적으로 관리할 수 있는 기능을 제공합니다.
파일 시스템 또는 객체 스토리지 (예: Amazon S3)

이유: 트윗에 첨부되는 이미지나 동영상과 같은 멀티미디어 콘텐츠를 저장하기 위해 사용합니다. 객체 스토리지 서비스는 대규모의 멀티미디어 파일을 저장하고 관리하기에 적합하며, 전 세계 어디서나 빠르게 콘텐츠를 제공할 수 있도록 지원합니다.

~~~

# 5

> 아래 질문을 개발자의 관점으로 최대한 상세히 서술해줘
> 사용자의 모든 활동기록(UserAction)을 파티셔닝해서 모아놓는 database가 있습니다.
> 2023-02 활동기록은 user-actions-2023-02,
> 2023-01 활동기록은 user-actions-2023-01,
> 2022-12 활동기록은 user-actions-2022-12,
> (모든 테이블은 id를 primary key로 사용하고 있고, auto increment 된다고 가정합니다.)
> 이번 달 활동기록뿐만 아니라 과거의 활동기록도 모두 보여줄 수 있는 GET /user-actions API를 제공하고자 합니다.
> 1. 페이지네이션을 어떻게 구현할 지 간단히 설명해주세요.
>    (별도의 라이브러리는 사용하지 않습니다. 코드 작성이 아니라 간결한 글로 설명해주세요.)
> 2. 클라이언트 개발자에게 API를 안내하기 위한 글을 작성해주세요.
>    (형식은 상관없습니다. API 문서 형태여도 좋고 이메일 형식이어도 좋습니다

~~~

### 페이지네이션 구현 방법 설명

페이지네이션을 구현하기 위해서는 먼저 사용자의 모든 활동 기록을 시간 순 또는 ID 순으로 정렬하는 것이 중요합니다. 각 테이블이 파티셔닝 되어 있으므로, 각 테이블에서 필요한 데이터를 가져온 뒤, 이를 합쳐서 최종 결과를 생성해야 합니다. 다음 단계로 구현 방법을 설명합니다:

1. **시작점과 페이지 크기 결정**: 클라이언트로부터 시작점(예: `start=0`)과 페이지 크기(예: `limit=10`)를 파라미터로 받습니다. 이를 통해 몇 번째 데이터부터 몇 개의 데이터를 반환할지 결정할 수 있습니다.
   
2. **쿼리 최적화**: 최신 데이터부터 조회하기 위해, 가장 최근의 테이블(예: `user-actions-2023-02`)부터 조회를 시작합니다. 필요한 데이터가 충분히 채워질 때까지 이전 달의 테이블로 쿼리를 확장합니다.

3. **데이터 합치기와 정렬**: 각 테이블에서 조회된 데이터를 합친 후, ID 또는 활동 시간 기준으로 정렬합니다. 이렇게 정렬된 데이터에서 클라이언트가 요청한 시작점부터 페이지 크기만큼의 데이터를 추출합니다.

4. **페이지네이션 정보 제공**: 응답에는 선택된 데이터뿐만 아니라, 다음 페이지를 위한 시작점 정보(예: 다음 `start` 값)도 포함하여 클라이언트가 다음 데이터를 요청할 수 있도록 합니다.

### 클라이언트 개발자를 위한 API 안내 글

안녕하세요,

사용자의 활동 기록을 조회할 수 있는 `GET /user-actions` API에 대해 안내드립니다. 이 API를 통해 사용자의 이번 달 활동 기록뿐만 아니라 과거 활동 기록도 조회할 수 있습니다.

#### 요청 방법

- **Endpoint**: `GET /user-actions`
- **Parameters**:
  - `start`: 조회를 시작할 기록의 인덱스 (기본값: 0)
  - `limit`: 한 번에 반환할 기록의 수 (기본값: 10)

#### 응답 구조

응답은 JSON 형식으로 반환되며, 다음과 같은 필드를 포함합니다:

- `data`: 활동 기록의 배열
- `nextStart`: 다음 페이지 조회를 위한 시작점 값
- `limit`: 요청된 페이지 크기

#### 예시 요청

```
GET /user-actions?start=0&limit=10
```

#### 예시 응답

```json
{
  "data": [
    {
      "id": 1,
      "action": "로그인",
      "createdAt": "2023-02-15T12:34:56Z"
    },
    // 추가 기록들...
  ],
  "nextStart": 10,
  "limit": 10
}
```

이 API를 통해 사용자 활동 기록을 효율적으로 조회할 수 있으며, 페이지네이션을 사용하여 대량의 데이터를 쉽게 탐색할 수 있습니다. 추가 질문이 있으시면 언제든지 연락주세요.

감사합니다.


~~~

# 6

> 아래 질문을 개발자의 관점으로 최대한 상세히 서술해줘
> 우리 팀에서는 JSON 형식의 Body를 주고받는 RESTful API를 Java로 개발하기 위해 Request, Response Body를 담을 DTO를 정의하고 있습니다.
> 고객의 예약 정보를 조회하는 API를 설계하라는 업무가 주어졌는데, 이 예약 정보에는 생성 시각이 포함되어 있고, 이는 Microsecond 단위의 Timestamp로 Relational Database에 저장되어 있습니다.
> 1. 이 Timestamp를 어떤 자료형으로, 어떻게 구조화하여 표현하는 것이 가장 바람직한 방법일지 명확한 근거와 함께 논해 주세요.
> 2. 결정한 내용을 다른 엔지니어들에게 전파하려고 합니다. 명확한 전파를 위한 이메일을 작성해 주세요.

~~~

### Timestamp 구조화 방법

Microsecond 단위의 Timestamp를 Java의 DTO에서 어떻게 구조화하고 표현하는 것이 가장 바람직한지에 대해 논의해 보겠습니다.

1. **자료형 선택**: Java에서는 `java.time.Instant` 또는 `java.time.LocalDateTime` 클래스를 사용하여 Timestamp를 표현할 수 있습니다. 하지만 이들 클래스는 기본적으로 나노초(nanosecond)까지 지원합니다. 따라서 Microsecond 단위의 정밀도를 필요로 하는 경우, 이 자료형들을 사용하여도 충분히 표현이 가능합니다.

2. **근거**:
   - `java.time.Instant`는 UTC 시각을 나노초 단위로 표현하며, 타임존에 무관한 글로벌 표준 시각을 나타내기에 적합합니다.
   - `java.time.LocalDateTime`은 타임존을 고려하지 않는 지역 시각을 나타내며, 사용 시 시스템의 기본 타임존 설정에 영향을 받지 않습니다.
   - Microsecond 단위의 정밀도는 이러한 자료형들의 나노초 지원을 통해 충분히 표현할 수 있으므로, 별도의 커스텀 자료형을 정의할 필요가 없습니다.

3. **구조화 방법**: API 응답에서 Timestamp를 전송할 때는 일반적으로 ISO 8601 형식의 문자열로 변환하여 제공하는 것이 좋습니다. 이는 표준화된 날짜 및 시각 표현 방식을 제공하기 때문에, API를 사용하는 클라이언트 측에서 다루기 용이합니다. `java.time.format.DateTimeFormatter`를 사용하여 쉽게 변환할 수 있습니다.

### 이메일 내용

제목: 예약 정보 조회 API 개발 관련 - Timestamp 처리 방법 공유

안녕하세요, 팀원 여러분,

예약 정보 조회 API 개발 과정에서 사용될 Timestamp 데이터 처리 방법에 대해 공유드립니다.

우리가 다루게 될 예약 정보 중 생성 시각은 Microsecond 단위의 Timestamp로 데이터베이스에 저장되어 있습니다. 이를 효과적으로 처리하고 API를 통해 전달하기 위해, Java의 `java.time.Instant` 또는 `java.time.LocalDateTime` 자료형을 사용하기로 결정했습니다. 이들 자료형은 나노초 단위까지 지원하므로, 우리의 필요사항을 충분히 만족시킵니다.

API 응답에서 이 Timestamp를 클라이언트에 전달할 때는, 가독성과 표준화를 위해 ISO 8601 형식의 문자열로 변환하여 제공할 계획입니다. 이 과정은 `java.time.format.DateTimeFormatter`를 사용하여 손쉽게 수행할 수 있습니다.

다음은 간단한 예시 코드입니다:

```java
Instant instant = Instant.now(); // 현재 UTC 시각을 나노초 정밀도로 획득
DateTimeFormatter formatter = DateTimeFormatter.ISO_INSTANT;
String formatted = formatter.format(instant);
System.out.println(formatted); // 예: 2023-02-20T12:34:56.123456Z
```

이 방법을 통해, 우리는 클라이언트가 사용하기 편리한 형태로 정확하고 효율적인 데이터 표현을 제공할 수 있을 것입니다.

프로젝트 진행에 참고해 주시고, 추가 질문이나 제안사항이 있으시면 언제

~~~


# 7

> 아래 질문을 개발자의 관점으로 최대한 상세히 서술해줘
> 이벤트 패키지 상품을 판매해야 합니다.
> 단, 해당 패키지 상품 중 유니크 상품은 선착순이 아니며, 사용자들에게 특정 확률로 꾸준히 판매가 이뤄지고 요일별 희망하는 유니크 판매 수량은 정해져 있습니다.
> (일주일간 지속적으로 구매자들에게 패키지 상품이 이슈되면서 판매 되길 희망합니다.) 하루 동안 유니크 상품의 판매량은 넘어서면 안되고, 하루 내에도 시간대별로 꾸준히 구매가 이뤄지길 바랍니다.
> 패키지 상품이 판매되면서 정해진 조건에 유니크 상품이 구매자들에게 얻게 하려면 어떻게 구현을 해야 할지 편하게 설명해 주세요.
> (코드작성은 하지 않습니다. 구현하고자 하는 내용을 프로세스별로 정리해서 해당 프로세스의 로직을 설명해주시면 됩니다.)
> [조건]
> 1. 패키지 상품 정보
>    : 패키지 상품
>    - A. 상품 (필수)
>    - B. 상품 (필수)
>    - C. 상품 (유니크 옵션으로 당첨자는 수량으로 1개 지급, 미당첨자는 수량으로 0개 지급 처리됩니다.)
>    2. 판매 기간
>    : 23년 5월 1일(월) ~ 23년 5월 7일(일)
>    3. C 상품 (유니크) 정보 : 재고 수 (1,000개)
>    4. 희망하는 유니크 상품 일별 판매 수 (일별 판매량에 못미치면 남은 재고 수는 다음 날로 이월됩니다.)
>    - 1일 (200개)
>    - 2일 (100개)
>    - 3일 (100개)
>    - 4일 (100개)
>    - 5일 (200개)
>    - 6일 (200개)
>    - 7일 (100개)
>    5. 구매 방법
>    : 구매자가 여러 번 구매 가능합니다.
>    6. 배치
>    : 시스템 상에 1시간 마다 배치 등록이 가능합니다.

~~~

1. 판매량 및 확률 관리 시스템 구축
일별 판매 목표 설정: 먼저, 일주일 동안 각 요일별로 유니크 상품의 판매 목표량을 설정합니다. 이 목표량은 시스템에 사전에 입력되어, 각 일자별로 판매해야 할 유니크 상품 수를 정확히 알 수 있게 합니다.
시간대별 할당량 계산: 각 요일의 판매 목표량을 기준으로, 하루를 예를 들어 24시간 단위로 나누고, 각 시간대별로 판매할 유니크 상품의 수량을 균등하게 배분합니다. 이는 하루 내내 꾸준한 판매가 이루어질 수 있도록 하기 위함입니다.

2. 구매 시도 시 당첨 확률 계산 및 처리
동적 확률 계산: 구매자가 패키지 상품을 구매할 때마다, 시스템은 해당 시간대에 남아있는 유니크 상품의 수량과 남은 시간, 그리고 전체 구매 시도 횟수를 기반으로 당첨 확률을 동적으로 계산합니다. 이 확률은 하루가 진행되면서 조정되어, 공정한 기회가 유지될 수 있도록 합니다.
당첨 처리: 구매 시도가 이루어지면, 계산된 확률에 따라 유니크 상품의 당첨 여부를 결정하고, 당첨된 구매자에게는 유니크 상품이 지급됩니다. 당첨되지 않은 경우에는 유니크 상품이 지급되지 않습니다.

3. 일일 판매량 모니터링 및 조정
배치 작업을 통한 모니터링: 시스템은 1시간마다 배치 작업을 실행하여, 그 시간 동안의 판매 데이터를 분석하고, 남은 유니크 상품의 수량을 확인합니다. 이를 통해, 각 요일의 판매 목표량에 도달했는지, 또는 초과하지 않았는지를 확인할 수 있습니다.
할당량 조정: 일일 판매량이 목표에 미치지 못하거나, 특정 시간대에 판매가 집중되는 경우, 남은 시간대의 유니크 상품 할당량을 조정하여, 남은 재고가 고르게 분배될 수 있도록 합니다. 목표량을 초과할 위험이 있을 경우 확률을 낮춰 조정합니다.

4. 사용자 안내 및 피드백
구매자 안내: 시스템은 구매자에게 패키지 상품 구매 시 유니크 상품에 대한 당첨 확률이 존재함을 명확히 안내합니다. 또한, 구매 시점에 관계없이 모든 사용자에게 공정한 기회가 주어진다는 점을 강조합니다. 이는 사용자가 언제든지 구매를 시도할 수 있도록 독려하고, 유니크 상품의 판매가 하루 종일 꾸준히 이루어지도록 유도하는 데 도움이 됩니다.


~~~
